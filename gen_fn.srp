# gen_fn.srp - fns generating percussion and melody
#

    # compute a measure using these variables:
    #    cur_style - a symbol representing style to play (if
    #       this is not your style, do not play)
    #    cur_start_beat - what beat to start on if you are stopped
    #    cur_stop_beat - what beat to stop on if you have started (you can
    #       stop slightly late; generally you should not start any notes 
    #       at or after tm_stop_beat but you can play a short note on 
    #       tm_stop_beat if it is stylistically sensible.)
    #    cur_beats_per_measure - the current time signature as an integer
    #    cur_bps - current beats per second (the vtsched will implement this
    #       but reading the vtsched timemap slope is not reliable because
    #       vtsched may be updated instantaneously after this call.
    #    cur_scale - boolean array representing current scale
    #    cur_chord - boolean array representing current chord
    #    cur_bass - integer representing root of chord
    #
    # Use EPSILON here because comparing floats for equality is not
    #   reliable without very difficult analysis. So, instead of
    #   x >= y, we write x + EPSILON > y

def play_percussion(int index, str prev_style): 
    #default patterns
    pattern_jazz = [0.5, 1, 0.5, 0.2, 0.8]
    pattern_tango = [1.5, 1.5, 1, 1.5, 1.5, 1]
    pattern_waltz = [1, 1, 1]
    pattern_rhumba = [0.5, 0.25, 0, 0.25, 0, 0.5]
    pattern_tap = [0.5, 0.5, 0.5, 0.5]]
    default_patterns = [pattern_jazz, pattern_tango, pattern_waltz, 
                        pattern_rhumba, pattern_tap]

    instr = track.getInstrument()

    if (user_input != ""):
        #choose a pattern using user input
        if (cur_style == 'jazz'):
            perc_pattern = pattern_jazz
        else if (cur_style == 'tango'):
            perc_pattern = pattern_tango
        else if (cur_style == 'waltz'):
            perc_pattern = pattern_waltz
        else if (cur_style == 'rhumba'):
            perc_pattern = pattern_rhumba
        else if (cur_style == 'tap'):
            perc_pattern = pattern_tap
        else:
            pattern = irandom(4)
            perc_pattern = default_patterns[pattern]
    else:
        perc_pattern = user_input

    #reset duration to be played only if style changed or out_of_range
    if (prev_style != cur_style):
        prev_style = cur_style
        index = 0
    if (index > len(perc_pattern)):
        cur_index % len(perc_pattern)

    #play percussion
    midi_out.note_on(hex(instr), 60, vel(80))

    #schedule using current duration
    sched_cause(perc_pattern[index], nil, 'play_percussion', index++, prev_style)
        
def gen_melody_array(bool[] cur_scale):
    prob = []
    note_prob = []

    #gnerate array of probabilities of moving from one note to another
    for note in range(0, len(cur_scale)):
        if cur_scale[i] == 1:
            note_prob = get_prob(i, scale)
            prob.append(note_prob)
        else:
            prob.append([])

    return prob

def gen_note_prob(int note, bool[] cur_scale):
    num_notes = len(cur_scale)
    prob_arr = []
    
    #generate probability by considering distance between two notes
    for i in range(0, num_notes):
        if (cur_scale[i] == 1):
            if (i == note):
                prob_arr.append(irandom(5))
            else:
                distance = abs(note - cur_scale[i])-1
                prob_arr.append(irandom(10 - distance))
        else:
            prob_arr.append(0)

     return prob_arr

def get_next_note(int[] prob):
#return note with max prob for now

    for i in range 0 to len(prob):
        if prob[i] == max(prob):
            return i

def play_melody_auto(int index, int note, int prev_note, int[][] prob, 
                int instr, int[] dur):
    if (prev_note != 0):
        midi_out.note_on(hex(instr), prev_note, 0)

    index = index % len(cur_scale)

    int[] note_prob = prob[note]
    next_note = get_next_note(note_prob)

    midi_out.note_on(hex(instr), note, velocity)
    sched_cause(dur[index], nil, 'play_melody', index++, next_note, note, prob, instr, dur) 

def play_melody_user(int index, int[][] arr):
    int instr = track.get_instrument()
    cur_index = index

    if (index > len(arr)):
        cur_index = index % len(arr)

    (note, duration, volume) = arr[cur_index][0]

    if (index > 0):
        if (cur_index == 0):
            (prev_note, prev_dur, prev_vol) = arr[len(arr)-1][0]
            midi_out.note_on(hex(instr), prev_note, 0)
        else:
            (prev_note, prev_dur, prev_vol) = arr[cur_index-1]
            midi_out.note_on(hex(instr), prev_note, 0)

    midi_out.note_on(hex(instr), note, volume)
    sched_cause(duration, nil, 'play_melody_user', index++, track.array)

def play_melody():
    if track.array != []:
        play_melody_user(0, track.array)
    else:
        int[][] prob = gen_melody_array(cur_scale)
        play_melody_auto(0, cur_bass, 0, prob, track.get_instrument(), dur)


