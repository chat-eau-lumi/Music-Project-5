# gen_fn.srp - fns generating percussion and melody
#

    # compute a measure using these variables:
    #    cur_style - a symbol representing style to play (if
    #       this is not your style, do not play)
    #    cur_start_beat - what beat to start on if you are stopped
    #    cur_stop_beat - what beat to stop on if you have started (you can
    #       stop slightly late; generally you should not start any notes 
    #       at or after tm_stop_beat but you can play a short note on 
    #       tm_stop_beat if it is stylistically sensible.)
    #    cur_beats_per_measure - the current time signature as an integer
    #    cur_bps - current beats per second (the vtsched will implement this
    #       but reading the vtsched timemap slope is not reliable because
    #       vtsched may be updated instantaneously after this call.
    #    cur_scale - boolean array representing current scale
    #    cur_chord - boolean array representing current chord
    #    cur_bass - integer representing root of chord
    #
    # Use EPSILON here because comparing floats for equality is not
    #   reliable without very difficult analysis. So, instead of
    #   x >= y, we write x + EPSILON > y

def play_percussion(index, prev_style): 
    #default patterns
    pattern_jazz = [0.5, 1, 0.5, 0.2, 0.8]
    pattern_tango = [1.5, 1.5, 1, 1.5, 1.5, 1]
    pattern_waltz = [1, 1, 1]
    pattern_rhumba = [0.5, 0.25, 0, 0.25, 0, 0.5]
    pattern_tap = [0.5, 0.5, 0.5, 0.5]
    default_patterns = [pattern_jazz, pattern_tango, pattern_waltz, 
                        pattern_rhumba, pattern_tap]

    instr = track.getInstrument()

    if (user_input != ""):
        #choose a pattern using user input
        if (cur_style == 'jazz'):
            perc_pattern = pattern_jazz
        elif (cur_style == 'tango'):
            perc_pattern = pattern_tango
        elif (cur_style == 'waltz'):
            perc_pattern = pattern_waltz
        elif (cur_style == 'rhumba'):
            perc_pattern = pattern_rhumba
        elif (cur_style == 'tap'):
            perc_pattern = pattern_tap
        else:
            pattern = irandom(4)
            perc_pattern = default_patterns[pattern]
    else:
        perc_pattern = user_input

    #reset duration to be played only if style changed or out_of_range
    if (prev_style != cur_style):
        prev_style = cur_style
        index = 0
    if (index > len(perc_pattern)):
        cur_index % len(perc_pattern)

    #play percussion
    midi_out.note_on(hex(instr), 60, vel(80))

    index = index + 1

    #schedule using current duration
    sched_cause(perc_pattern[index], nil, 'play_percussion', index, prev_style)
        
def gen_melody_array(cur_scale):
    prob = []
    note_prob = []

    #gnerate array of probabilities of moving from one note to another
    for note in range(0, len(cur_scale)):
        if cur_scale[i] == 1:
            note_prob = get_prob(i, scale)
            prob.append(note_prob)
        else:
            prob.append([])

    return prob

def gen_note_prob(note, cur_scale):
    num_notes = len(cur_scale)
    prob_arr = []
    
    #generate probability by considering distance between two notes
    for i in range(0, num_notes):
        if (cur_scale[i] == 1):
            if (i == note):
                prob_arr.append(irandom(5))
            else:
                distance = abs(note - cur_scale[i])-1
                prob_arr.append(distance + irandom(10 - distance))
        else:
            prob_arr.append(0)
    return prob_arr

def get_next_note(prob, prev_note):
#return note with max prob for now
    next_note = 0
    max = prob[0]

    for i in range(1, len(prob)):
        if prob[i] > max:
            max = prob[i]
            next_note = i
    if cur_scale[i] == prev_note:
        prob = prob.remove(max)        
        next_note = get_next_note(prob, prev_note)

    return next_note

def play_melody_auto(index, note, prev_note, prob, instr, dur):
    if (prev_note != 0):
        midi_out.note_on(hex(instr), prev_note, 0)

    index = index % len(cur_scale)

    note_prob = prob[note]
    next = get_next_note(note_prob, prev_note)

    midi_out.note_on(hex(instr), note, velocity)
    index = index + 1

    sched_cause(dur[index], nil, 'play_melody', index, cur_scale[next], note, prob, instr, dur) 

def play_melody_user(index, arr):
    instr = track.get_instrument()
    cur_index = index

    if (index > len(arr)):
        cur_index = index % len(arr)

    cur_arr = arr[cur_index][0]
    note = cur_arr[0]
    duration = cur_arr[1]
    volume = cur_arr[2]

    if (index > 0):
        if (cur_index == 0):
            prev_arr = arr[len(arr)-1][0]
            prev_note = prev_arr[0]

            midi_out.note_on(hex(instr), prev_note, 0)
        else:
            prev_arr = arr[cur_index-1]
            prev_note = prev_arr[0]
            midi_out.note_on(hex(instr), prev_note, 0)

    midi_out.note_on(hex(instr), note, volume)
    index = index + 1
    
    sched_cause(duration, nil, 'play_melody_user', index, track.array)

def play_melody():
    if track.array != []:
        play_melody_user(0, track.array)
    else:
        prob = gen_melody_array(cur_scale)
        play_melody_auto(0, cur_bass, 0, prob, track.get_instrument(), dur)


