require "dataStruct"
require "sched"
require "prefs"
require "midi-io"
require "mididevice"
require "wxserpent"
require "slider"
require "debug"
#require "playerdemo"


# gen_fn.srp - fns generating percussion and melody
#

    # compute a measure using these variables:
    #    cur_style - a symbol representing style to play (if
    #       this is not your style, do not play)
    #    cur_start_beat - what beat to start on if you are stopped
    #    cur_stop_beat - what beat to stop on if you have started (you can
    #       stop slightly late; generally you should not start any notes 
    #       at or after tm_stop_beat but you can play a short note on 
    #       tm_stop_beat if it is stylistically sensible.)
    #    cur_beats_per_measure - the current time signature as an integer
    #    cur_bps - current beats per second (the vtsched will implement this
    #       but reading the vtsched timemap slope is not reliable because
    #       vtsched may be updated instantaneously after this call.
    #    cur_scale - boolean array representing current scale
    #    cur_chord - boolean array representing current chord
    #    cur_bass - integer representing root of chord
    #
    # Use EPSILON here because comparing floats for equality is not
    #   reliable without very difficult analysis. So, instead of
    #   x >= y, we write x + EPSILON > y


#default patterns
pattern_jazz = [0.5, 1, 0.5, 0.2, 0.8]
pattern_tango = [1.5, 1.5, 1, 1.5, 1.5, 1]
pattern_waltz = [1, 1, 1]
pattern_rhumba = [0.5, 0.25, 0, 0.25, 0, 0.5]
pattern_tap = [0.5, 0.5, 0.5, 0.5]
default_patterns = [pattern_jazz, pattern_tango, pattern_waltz, 
                    pattern_rhumba, pattern_tap]

#melody duration arrays
dur_2_4 = [[2,2],[1,3],[1.5,2.5]]
dur_2_3 = [[1,2],[2,1],[1.5,1.5],[2.5,0.5]]
dur_3_4 = [[1,2,1],[1.5,1.5,1],[3,0.5,0.5],[2,1.75,0.25]]
dur_3_3 = [[1,1,1],[1.5,0.5,1],[2,0.5,0.5],[1,1.75,0.25]]
allDurations = [dur_2_4, dur_2_3, dur_3_4, dur_3_3]

#melody pitch arrays

# need to write get prob
cur_scale = [t, nil, t, nil, t, t, nil, t, nil, t, nil, t]
cur_bass = 0
cur_style = ""
cur_beats_per_measure = 4
cur_bps = 0.5

def play_percussion():
    newTrack = track([], 1, "perc")
    display newTrack.getInstrument()
    play_percussion_auto(0, "", newTrack)

def gen_percussion_auto(): 
    if (cur_style == 'jazz'):
        perc_pattern = pattern_jazz
    elif (cur_style == 'tango'):
        perc_pattern = pattern_tango
    elif (cur_style == 'waltz'):
        perc_pattern = pattern_waltz
    elif (cur_style == 'rhumba'):
        perc_pattern = pattern_rhumba
    elif (cur_style == 'tap'):
        perc_pattern = pattern_tap
    else:
        pattern = irandom(4)
        perc_pattern = default_patterns[pattern]

    index = index + 1
    #reset duration to be played only if style changed or out_of_range

    perc_arr = []
    perc_arr.append([])

    curBeat = cur_beats_per_measure
    total = sum(perc_pattern)
    curFactor = curBeat / total
    newList = []
    # make sure that list of durations is relative to current beat
    for i = 0 to len(perc_pattern):
        newList.append(curFactor * perc_pattern[i])

    duration = []
    curBPS = cur_bps
    # calculate duration for each beat
    for i = 0 to len(perc_pattern):
        duration.append(curFactor[i] / curBPS)

    # add four measures to perc arr
    for i = 0 to 4:
        for x = 0 to len(perc_pattern):
            newNote = note(60, 1, 80, duration[x])
            perc_arr.append(newNote)
    
    return perc_arr

def get_key(cur_scale):
    #get key from scale

    if (cur_scale[6] == nil and cur_scale[1] == nil):
        #C major
        key = 0 
    elif (cur_scale[6] == "t" and cur_scale[1] == nil):
        #D major
        #key = 
    elif (cur_scale[6] == "t" and cur_scale[1] == "t" and
            cur_scale[8] == nil):
        #A major
        #key = 
    elif (cur_scale[6] == "t" and cur_scale[1] == "t" and
            cur_scale[8] == "t" and cur_scale[3] == nil):
        #E major
        #key = 
    elif (cur_scale[6] == "t" and cur_scale[1] == "t" and 
            cur_scale[8] == "t" and cur_scale[3] == "t" and
            cur_scale[11] == nil):
        #B major
        #key = 
    elif (cur_scale[6] == "t" and cur_scale[1] == "t" and
            cur_scale[8] == "t" and cur_scale[3] == "t" and
            cur_scale[11] == "t" and cur_scale[4] == nil):
        #F sharp major
        #key = 
    elif (cur_scale[6] == "t" and cur_scale[1] == "t" and
            cur_scale[8] == "t" and cur_scale[3] == "t" and
            cur_scale[11] == "t" and cur_scale[4] == "t" and
            cur_scale[0] == "t"):
        #C sharp major
        #key =
    elif (cur_scale[10] == "t" and cur_scale[3] == nil):
        #F major 
        #key =
    elif (cur_scale[10] == "t" and cur_scale[3] == "t" and
            cur_scale[8] == nil):
        #B flat major
        #key =
    elif (cur_scale[10] == "t" and cur_scale[3] == "t" and
            cur_scale[8] == "t" and cur_scale[1] == nil):
        #E flat major
        #key =
    elif (cur_scale[10] == "t" and cur_scale[3] == "t" and
            cur_scale[8] == "t" and cur_scale[1] == "t" and
            cur_scale[6] == nil):
        #A flat major
        #key = 
    elif (cur_scale[10] == "t" and cur_scale[3] == "t" and
            cur_scale[8] == "t" and cur_scale[1] == "t" and
            cur_scale[6] == "t" and cur_scale[11] ==  nil):
        #D flat major
        #key = 
    elif (cur_scale[10] == "t" and cur_scale[3] == "t" and
            cur_scale[8] == "t" and cur_scale[1] == "t" and
            cur_scale[6] == "t" and cur_scale[11] ==  "t" and
            cur_scale[4] == nil):
        #G flat major
        #key = 
    elif (cur_scale[10] == "t" and cur_scale[3] == "t" and
            cur_scale[8] == "t" and cur_scale[1] == "t" and
            cur_scale[6] == "t" and cur_scale[11] ==  "t" and
            cur_scale[4] == "t"):
        #C flat major
        #key = 

    #return key
    return 0

def get_pitch(count):
    return 60

def get_dur(measure, noteIndex, durInd):
    curArray = allDurations[durInd]
    curMeasure = curArray[measure]
    curDur = curMeasure[noteIndex]
 
    return curDur

def gen_melody_array(scale):
    prob = []
    note_prob = []

    #generate array of probabilities of moving from one note to another
    for note=0 to 12:
        if cur_scale[note] == t:
            note_prob = gen_note_prob(note, cur_scale)
            prob.append(note_prob)
        else:
            prob.append(0)

    return prob

def gen_note_prob(note, cur_scale):
    num_notes = len(cur_scale)
    prob_arr = []
    
    #generate probability by considering distance between two notes
    for i=0 to num_notes:
        if (cur_scale[i] == 't'):
            if (i == note):
                prob_arr.append(irandom(5))
            else:
                distance = abs(note - i)-1
                prob_arr.append(irandom(distance))
        else:
            prob_arr.append(0)
    return prob_arr

def gen_melody_motif():
    #generate array of notes based on existing pitch sequence and durations
    melody_arr = []
    durIndex = int(random() * 4)
    
    for i=0 to 4:
        for j=0 to len(pitch_arr):
            pitch = get_pitch(j)
            dur = get_dur(i, j, durIndex)

            key = get_key(cur_scale)
            cur_note = note(pitch, key, 80, dur) 
            
            melody_arr.append(cur_note)

    return melody_arr
    
def play_melody_user(index, curTrack):

    arr = curTrack.array
    instr = curTrack.getInstrument()
    cur_index = index

    if (index > len(arr)):
        cur_index = index % len(arr)

    cur_arr = arr[cur_index][0]
    note = cur_arr.pitch 
    duration = cur_arr.sduration
    volume = cur_arr.volume

    if (index > 0):
        if (cur_index == 0):
            prev_arr = arr[len(arr)-1][0]
            lenPrev = len(prev_arr)
            
            # turn off all notes in prev array
            for i=0 to (lenPrev):
                curNote = prev_arr[i]
                prevPitch = curNote.pitch
                midi_out.note_on(instr, prevPitch,0)

        else:
            prev_arr = arr[cur_index-1]
            lenPrev = len(prev_arr)
            for i=0 to (lenPrev):
                curNote = prev_arr[i]
                prevPitch = curNote.pitch
                midi_out.note_on(instr, prevPitch,0)

    midi_out.note_on(instr, note, volume)
    index = index + 1
    
    sched_cause(duration, nil, 'play_melody_user', index, track.array)

#def play_melody():
#    newTrack = track([], 1, "melody")
#    prob = gen_melody_array(cur_scale)
#    display newTrack.array
#    display prob
#    play_melody_auto(prob, newTrack)

#def main():
    #random.seed(time_get())
    #sched_init(2)
    #prefs = Prefs("./prefs.txt")
    #midiDevices = Midi_devices(prefs, open_later = true)
    #success = midiDevices.open_midi(latency = 10, device = 'midi_out_device')
    #if not success
    #    print "PLEASE SELECT A VALID OUTPUT DEVICE AND RESTART THIS PROGRAM"
    #else
        #sched_select(vtsched)
        #sched_set_period(0.5)
        #sched_cause(real_delay(1), nil, 'play_melody')
        #sched_cause(real_delay(1), nil, 'play_percussion')

gen_melody_motif()
#main()
#play_melody()
