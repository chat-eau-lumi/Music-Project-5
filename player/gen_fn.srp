require "dataStruct"
require "sched"
require "prefs"
require "midi-io"
require "mididevice"
require "wxserpent"
require "slider"
require "debug"
#require "playerdemo"


# gen_fn.srp - fns generating percussion and melody
#

    # compute a measure using these variables:
    #    cur_style - a symbol representing style to play (if
    #       this is not your style, do not play)
    #    cur_start_beat - what beat to start on if you are stopped
    #    cur_stop_beat - what beat to stop on if you have started (you can
    #       stop slightly late; generally you should not start any notes 
    #       at or after tm_stop_beat but you can play a short note on 
    #       tm_stop_beat if it is stylistically sensible.)
    #    cur_beats_per_measure - the current time signature as an integer
    #    cur_bps - current beats per second (the vtsched will implement this
    #       but reading the vtsched timemap slope is not reliable because
    #       vtsched may be updated instantaneously after this call.
    #    cur_scale - boolean array representing current scale
    #    cur_chord - boolean array representing current chord
    #    cur_bass - integer representing root of chord
    #
    # Use EPSILON here because comparing floats for equality is not
    #   reliable without very difficult analysis. So, instead of
    #   x >= y, we write x + EPSILON > y


#default patterns
pattern_jazz = [0.5, 1, 0.5, 0.2, 0.8]
pattern_tango = [1.5, 1.5, 1, 1.5, 1.5, 1]
pattern_waltz = [1, 1, 1]
pattern_rhumba = [0.5, 0.25, 0, 0.25, 0, 0.5]
pattern_tap = [0.5, 0.5, 0.5, 0.5]
default_patterns = [pattern_jazz, pattern_tango, pattern_waltz, 
                    pattern_rhumba, pattern_tap]

#melody duration arrays
durations = [0.125, 0.25, 0.5, 1, 2, 3, 4]

#melody pitch arrays

# need to write get prob
cur_scale = [t, nil, t, nil, t, t, nil, t, nil, t, nil, t]
cur_bass = 0
cur_style = ""
cur_beats_per_measure = 4
cur_bps = 0.5

def play_percussion():
    newTrack = track([], 1, "perc")
    display newTrack.getInstrument()
    play_percussion_auto(0, "", newTrack)

def gen_percussion_auto(): 
    #if (user_input != ""):
        #choose a pattern using user input
    if (cur_style == 'jazz'):
        perc_pattern = pattern_jazz
    elif (cur_style == 'tango'):
        perc_pattern = pattern_tango
    elif (cur_style == 'waltz'):
        perc_pattern = pattern_waltz
    elif (cur_style == 'rhumba'):
        perc_pattern = pattern_rhumba
    elif (cur_style == 'tap'):
        perc_pattern = pattern_tap
    else:
        pattern = irandom(4)
        perc_pattern = default_patterns[pattern]
    #else:
    #    perc_pattern = user_input

    index = index + 1
    #reset duration to be played only if style changed or out_of_range
    #if (prev_style != cur_style):
    #    prev_style = cur_style
    #    index = 0
    #if (index > len(perc_pattern)-1):
    #    index = index % len(perc_pattern)

    perc_arr = []
    perc_arr.append([])

    for i=0 to 4:
        for j=0 to len(perc_pattern):
            cur_beat = note() 
            perc_arr[i].append(cur_beat)
        perc_arr.append([])
    
    return perc_arr

def get_pitch(count):
    return 60

def get_dur(count):
    return 1

def gen_melody_motif():
    melody_arr = []
    total_time = cur_beats_per_measure/cur_bps
    
    cur_time = 0
    count = 0

    for i=0 to 3:
        while (cur_time < total_time):
            pitch = get_pitch(count)
            dur = get_dur(count)
            cur_note = note(pitch, 0, 80, dur) 
            
            melody_arr.append(cur_note)
            cur_time = cur_time + dur
            count = count + 1
        cur_time = 0
        count = 0

    display melody_arr
    return melody_arr
    
def play_melody_user(index, curTrack):

    arr = curTrack.array
    instr = curTrack.getInstrument()
    cur_index = index

    if (index > len(arr)):
        cur_index = index % len(arr)

    cur_arr = arr[cur_index][0]
    note = cur_arr.pitch 
    duration = cur_arr.sduration
    volume = cur_arr.volume

    if (index > 0):
        if (cur_index == 0):
            prev_arr = arr[len(arr)-1][0]
            lenPrev = len(prev_arr)
            
            # turn off all notes in prev array
            for i=0 to (lenPrev):
                curNote = prev_arr[i]
                prevPitch = curNote.pitch
                midi_out.note_on(instr, prevPitch,0)

        else:
            prev_arr = arr[cur_index-1]
            lenPrev = len(prev_arr)
            for i=0 to (lenPrev):
                curNote = prev_arr[i]
                prevPitch = curNote.pitch
                midi_out.note_on(instr, prevPitch,0)

    midi_out.note_on(instr, note, volume)
    index = index + 1
    
    sched_cause(duration, nil, 'play_melody_user', index, track.array)

#def play_melody():
#    newTrack = track([], 1, "melody")
#    prob = gen_melody_array(cur_scale)
#    display newTrack.array
#    display prob
#    play_melody_auto(prob, newTrack)

#def main():
    #random.seed(time_get())
    #sched_init(2)
    #prefs = Prefs("./prefs.txt")
    #midiDevices = Midi_devices(prefs, open_later = true)
    #success = midiDevices.open_midi(latency = 10, device = 'midi_out_device')
    #if not success
    #    print "PLEASE SELECT A VALID OUTPUT DEVICE AND RESTART THIS PROGRAM"
    #else
        #sched_select(vtsched)
        #sched_set_period(0.5)
        #sched_cause(real_delay(1), nil, 'play_melody')
        #sched_cause(real_delay(1), nil, 'play_percussion')

gen_melody_motif()
#main()
#play_melody()
